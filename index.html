<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>å¤§æ–¹æ£‹ Â· è¿çº¿å¯¹æˆ˜</title>
<style>
:root {
--bg: #0f172a;
--text: #e5e7eb;
--muted: #94a3b8;
/* æµ…æ«æœ¨ï¼ˆMapleï¼‰é…è‰² */
--wood1: #f6deb7;
--wood2: #efd1a1;
--wood3: #e7c28a;
--panel: rgba(255, 255, 255, 0.06);
--panelBorder: rgba(255, 255, 255, 0.1);
}
* {
box-sizing: border-box;
}
body {
margin: 0;
font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
Helvetica, Arial;
background: radial-gradient(1200px 600px at 20% 0%, #1f2937, var(--bg));
color: var(--text);
padding: 16px;
}
.wrap {
max-width: 1100px;
margin: 0 auto;
display: grid;
grid-template-columns: 1.3fr 1fr;
gap: 16px;
}
.card {
background: linear-gradient(180deg,
rgba(255, 255, 255, 0.06),
rgba(255, 255, 255, 0.03));
border: 1px solid rgba(255, 255, 255, 0.08);
border-radius: 14px;
padding: 14px;
box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
}
h1 {
font-size: 18px;
margin: 0 0 10px 0;
letter-spacing: 0.5px;
}
.appTitle {
text-align: center;
margin: 0 0 10px 0;
}
.sub {
font-size: 12px;
color: var(--muted);
margin-top: -2px;
margin-bottom: 10px;
line-height: 1.4;
}
.row {
display: flex;
gap: 10px;
flex-wrap: wrap;
align-items: center;
}
button,
select {
background: rgba(255, 255, 255, 0.07);
border: 1px solid rgba(255, 255, 255, 0.12);
color: var(--text);
padding: 8px 10px;
border-radius: 10px;
cursor: pointer;
}
select {
cursor: default;
}
button:hover {
border-color: rgba(255, 255, 255, 0.22);
}
button.primary {
background: rgba(34, 197, 94, 0.18);
border-color: rgba(34, 197, 94, 0.35);
}
button.danger {
background: rgba(239, 68, 68, 0.18);
border-color: rgba(239, 68, 68, 0.35);
}
button:disabled {
opacity: 0.45;
cursor: not-allowed;
}
.badge {
display: inline-flex;
align-items: center;
padding: 4px 8px;
border-radius: 999px;
border: 1px solid rgba(255, 255, 255, 0.12);
background: rgba(0, 0, 0, 0.18);
font-size: 12px;
color: var(--muted);
gap: 6px;
}
.badge strong {
color: var(--text);
}
.log {
background: rgba(0, 0, 0, 0.25);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 12px;
padding: 10px;
height: 340px;
overflow: auto;
font-size: 12px;
line-height: 1.45;
white-space: pre-wrap;
}
.log {
user-select: text;
-webkit-user-select: text;
cursor: text;
overscroll-behavior: contain;
}
.gridWrap {
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
padding: 8px;
gap: 10px;
}
canvas {
width: 520px;
height: 520px;
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 16px;
cursor: pointer;
touch-action: manipulation;
background: repeating-linear-gradient(90deg,
rgba(255, 255, 255, 0.12) 0px,
rgba(255, 255, 255, 0.12) 1px,
rgba(255, 255, 255, 0) 6px,
rgba(255, 255, 255, 0) 22px),
repeating-linear-gradient(0deg,
rgba(0, 0, 0, 0.04) 0px,
rgba(0, 0, 0, 0.04) 2px,
rgba(0, 0, 0, 0) 14px,
rgba(0, 0, 0, 0) 28px),
linear-gradient(180deg, var(--wood1), var(--wood2));
}
.hint {
font-size: 12px;
color: var(--muted);
margin-top: 8px;
line-height: 1.5;
}
.kpi {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 10px;
margin-top: 10px;
}
.kpi .box {
background: rgba(0, 0, 0, 0.2);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 12px;
padding: 10px;
font-size: 12px;
}
.box .label {
color: var(--muted);
margin-bottom: 4px;
}
.box .val {
font-size: 14px;
}
.selectLine {
margin-top: 8px;
color: var(--muted);
font-size: 12px;
}
.mono {
font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
"Liberation Mono", "Courier New", monospace;
}
#selLevel {
background: rgba(0, 0, 0, 0.45);
color: var(--text);
border: 1px solid rgba(255, 255, 255, 0.2);
padding: 4px 10px;
border-radius: 10px;
}
#selLevel option {
background: #111827;
color: #f9fafb;
}
#selLevel:focus {
outline: 2px solid rgba(245, 158, 11, 0.7);
outline-offset: 2px;
}
@media (max-width: 860px) {
.wrap { grid-template-columns: 1fr; }
canvas { width: min(92vw, 640px); height: auto; }
}
@media (max-width: 420px) {
.row { grid-template-columns: 1fr; }
button, select { width: 100%; }
}
.boardActions {
display: flex;
justify-content: center;
gap: 8px;
flex-wrap: wrap;
margin-top: 8px;
}
.boardActions button {
font-size: 14px;
padding: 6px 10px;
border-radius: 10px;
}
</style>
</head>
<body>
<div class="wrap">
<div class="card boardCard">
<h1 class="appTitle">å¤§æ–¹æ£‹ Â· è¿çº¿å¯¹æˆ˜</h1>
<div class="gridWrap">
<canvas id="cv" width="600" height="600"></canvas>
<div class="boardActions">
<button class="primary" id="btnQuickMatch">å¿«é€Ÿå¯¹æˆ˜</button>
<button id="btnCreateRoom">åˆ›å»ºæˆ¿é—´</button>
<input id="roomIdInput" placeholder="æˆ¿é—´å·ï¼ˆ4ä½æ•°å­—ï¼‰" style="width:120px;padding:6px;font-size:14px;background:#1e293b;border:1px solid #334155;color:white;">
<button id="btnJoinRoom">åŠ å…¥æˆ¿é—´</button>
<button id="btnSpectate">è§‚æˆ˜</button>
<button id="btnRematch">å†æ¥ä¸€å±€</button>
<button class="danger" id="btnResign">è®¤è¾“</button>
</div>
</div>
</div>
<div class="card infoCard">
<div class="row topbar">
<span class="badge">çŠ¶æ€ <strong id="connStatus">æœªè¿æ¥</strong></span>
<span class="badge">è§’è‰² <strong id="roleText">-</strong></span>
<span class="badge">æˆ¿é—´ <strong id="roomText">-</strong></span>
</div>
<div class="kpi">
<div class="box">
<div class="label">é˜¶æ®µ / å½“å‰è¡ŒåŠ¨</div>
<div class="val" id="stageText">-</div>
<div class="selectLine" id="actionHint">-</div>
</div>
<div class="box">
<div class="label">ä½ æ‰§</div>
<div class="val" id="humanColorText">-</div>
<div class="selectLine">è½®åˆ°ï¼š<span id="turnText">-</span></div>
</div>
<div class="box">
<div class="label">è¢«è‡ªæ‹†è®©å‡ºçš„ç©ºä½ï¼ˆé™åˆ¶ä¸‹ä¸€å›åˆæˆé˜µï¼‰</div>
<div class="val mono" id="forbiddenText">-</div>
<div class="selectLine">ä»…å½“â€œæ— é—²å­å¯åƒâ†’è‡ªæ‹†é˜µå‹å­â€æ‰ä¼šå‡ºç°</div>
</div>
</div>
<div class="hint">
ğŸ’¡ å¿«é€Ÿå¯¹æˆ˜ï¼šè‡ªåŠ¨åŒ¹é…å¯¹æ‰‹<br>
ğŸ‘€ è§‚æˆ˜ï¼šè¾“å…¥æˆ¿é—´å·åªçœ‹ä¸æ“ä½œ
</div>
</div>
<div class="card bottomCard">
<h1>å¯¹å±€æ—¥å¿—</h1>
<div class="log" id="log"></div>
<h1 style="margin-top: 12px">è¡Œæ£‹è§„åˆ™</h1>
<div class="sub">
6Ã—6 äº¤å‰ç‚¹ã€‚èµ°æ£‹ä»…å››é‚»æ¥ï¼›å¥–åŠ±=æœ¬æ¬¡åŠ¨ä½œæ–°å½¢æˆé˜µå‹ï¼ˆå¤åˆç´¯åŠ ï¼‰ã€‚<br>
ç¬¬äºŒé˜¶æ®µï¼šåƒå­é¢åº¦=2ï¼ˆè¢«åƒæ–¹è‡ªæ‹†è®©å‡ºçš„é˜µå‹å­ä¹Ÿè®¡å…¥é¢åº¦ï¼‰ã€‚<br>
é‡è¦ï¼šæ— é—²å­å¯åƒæ—¶ï¼Œåƒå­æ–¹ä¸Šæ­¥å·²ç»“æŸ â†’ ç«‹åˆ»åˆ‡åˆ°å¯¹æ–¹è®¡æ—¶å¹¶è¦æ±‚å¯¹æ–¹è‡ªæ‹†ã€‚<br>
âœ… è§„åˆ™æ ¡æ­£ï¼šè¾¹çº¿è¡Œ/åˆ—å½¢æˆçš„â€œé¾™â€ä¸ç®—é˜µå‹ã€ä¸å¥–åŠ±ã€‚
</div>
</div>
</div>
<script>
// ========== å¸¸é‡ ==========
const EMPTY = 0, BLACK = 1, WHITE = -1, SIZE = 6;
const DIR4 = [[-1,0],[1,0],[0,-1],[0,1]];
function colorName(c) { return c === BLACK ? "é»‘â—" : "ç™½â—‹"; }
function isBorder(x, y) { return x===0||x===SIZE-1||y===0||y===SIZE-1; }

// ========== æ¸¸æˆæ ¸å¿ƒï¼ˆçº¯é€»è¾‘ï¼Œæ—  DOMï¼‰==========
class DafangGameCore {
  constructor(humanColor) {
    this.humanColor = humanColor;
    this.aiColor = 0;
    this.board = Array.from({length:SIZE}, () => Array(SIZE).fill(EMPTY));
    this.stage = 1;
    this.turn = BLACK;
    this.over = false;
    this.winner = null;
    this.loseReason = "";
    this.placeRemaining = 1;
    this.placeRewardLocked = false;
    this.capturePlan = [
      {capturer:WHITE, victim:BLACK, left:2},
      {capturer:BLACK, victim:WHITE, left:2}
    ];
    this.captureIndex = 0;
    this.pendingCapture = 0;
    this.pendingCapturer = 0;
    this.pendingVictim = 0;
    this.needRelieve = false;
    this.relievePlayer = null;
    this.selfbreakMode = null;
    this.selected = null;
    this.moveInProgress = false;
    this.recentSelfbreakEmpty = {[BLACK]:new Set(),[WHITE]:new Set()};
    this.log = [];
  }

  // ========== å·¥å…·å‡½æ•° ==========
  inBounds(x, y) { return x >= 0 && x < SIZE && y >= 0 && y < SIZE; }
  countPieces(color) {
    let n = 0;
    for (let x = 0; x < SIZE; x++)
      for (let y = 0; y < SIZE; y++)
        if (this.board[x][y] === color) n++;
    return n;
  }
  _canMove(x, y) {
    for (const [dx, dy] of DIR4) {
      const nx = x + dx, ny = y + dy;
      if (this.inBounds(nx, ny) && this.board[nx][ny] === EMPTY) return true;
    }
    return false;
  }
  legalMoves(color) {
    const moves = [];
    for (let x = 0; x < SIZE; x++) {
      for (let y = 0; y < SIZE; y++) {
        if (this.board[x][y] !== color) continue;
        for (const [dx, dy] of DIR4) {
          const nx = x + dx, ny = y + dy;
          if (this.inBounds(nx, ny) && this.board[nx][ny] === EMPTY)
            moves.push([x, y, nx, ny]);
        }
      }
    }
    return moves;
  }

  // ========== é˜µå‹ç³»ç»Ÿ ==========
  enumeratePatterns(color) {
    const patterns = new Set();
    // æ–¹
    for (let x = 0; x < SIZE - 1; x++) {
      for (let y = 0; y < SIZE - 1; y++) {
        const cells = [[x,y],[x+1,y],[x,y+1],[x+1,y+1]];
        if (cells.every(([i,j]) => this.board[i][j] === color)) {
          patterns.add(this._patKey("SQUARE", cells));
        }
      }
    }
    // æ–œçº¿
    const diagStarts = (dx, dy) => {
      const s = [];
      if (dx === 1 && dy === 1) {
        for (let y = 0; y < SIZE; y++) s.push([0, y]);
        for (let x = 1; x < SIZE; x++) s.push([x, 0]);
      } else {
        for (let y = 0; y < SIZE; y++) s.push([0, y]);
        for (let x = 1; x < SIZE; x++) s.push([x, SIZE - 1]);
      }
      return s;
    };
    const collectDiag = (sx, sy, dx, dy) => {
      const a = []; let x = sx, y = sy;
      while (this.inBounds(x, y)) { a.push([x, y]); x += dx; y += dy; }
      return a;
    };
    const runsToPatterns = (diag) => {
      let i = 0;
      while (i < diag.length) {
        const [x, y] = diag[i];
        if (this.board[x][y] !== color) { i++; continue; }
        let j = i, run = [];
        while (j < diag.length && this.board[diag[j][0]][diag[j][1]] === color) {
          run.push(diag[j]); j++;
        }
        const L = run.length;
        if (L >= 3 && L <= 6) {
          const [sx, sy] = run[0], [ex, ey] = run[run.length - 1];
          if (isBorder(sx, sy) && isBorder(ex, ey)) {
            patterns.add(this._patKey(`DIAG${L}`, run));
          }
        }
        i = j;
      }
    };
    for (const [dx, dy] of [[1,1], [1,-1]]) {
      for (const [sx, sy] of diagStarts(dx, dy)) {
        runsToPatterns(collectDiag(sx, sy, dx, dy));
      }
    }
    // é¾™ï¼ˆæ’é™¤è¾¹çº¿ï¼‰
    for (let r = 1; r < SIZE - 1; r++) {
      if (this.board[r].every(v => v === color))
        patterns.add(this._patKey("DRAGON_ROW", Array.from({length: SIZE}, (_,c) => [r,c])));
    }
    for (let c = 1; c < SIZE - 1; c++) {
      let ok = true;
      for (let r = 0; r < SIZE; r++) if (this.board[r][c] !== color) { ok = false; break; }
      if (ok) patterns.add(this._patKey("DRAGON_COL", Array.from({length: SIZE}, (_,r) => [r,c])));
    }
    return patterns;
  }

  _patKey(kind, cells) {
    const sorted = cells.slice().sort((a,b)=>a[0]-b[0]||a[1]-b[1]).map(([x,y])=>`${x},${y}`).join("|");
    return `${kind}::${sorted}`;
  }

  _patParse(key) {
    const [kind, rest] = key.split("::");
    const cells = rest.split("|").map(s => s.split(",").map(Number));
    return { kind, cells };
  }

  newPatternsAndReward(beforeSet, afterSet) {
    const newOnes = [];
    let reward = 0;
    for (const k of afterSet) {
      if (!beforeSet.has(k)) {
        newOnes.push(k);
        reward += patternReward(this._patParse(k).kind);
      }
    }
    return { newOnes, reward };
  }

  patternMembers(color) {
    const mem = new Set();
    for (const k of this.enumeratePatterns(color)) {
      const { cells } = this._patParse(k);
      for (const [x, y] of cells) mem.add(`${x},${y}`);
    }
    return mem;
  }

  idlePositions(color) {
    const mem = this.patternMembers(color);
    const idle = [];
    for (let x = 0; x < SIZE; x++) {
      for (let y = 0; y < SIZE; y++) {
        if (this.board[x][y] === color && !mem.has(`${x},${y}`)) idle.push([x, y]);
      }
    }
    return idle;
  }

  moveForbiddenBySelfbreak(color, newPatternKeys) {
    const forb = this.recentSelfbreakEmpty[color];
    if (!forb || forb.size === 0) return false;
    for (const pk of newPatternKeys) {
      const { cells } = this._patParse(pk);
      for (const [x, y] of cells) if (forb.has(`${x},${y}`)) return true;
    }
    return false;
  }

  // ========== æ¸¸æˆæµç¨‹æ§åˆ¶ ==========
  _applyMove(x1, y1, x2, y2) {
    const c = this.board[x1][y1];
    this.board[x1][y1] = EMPTY;
    this.board[x2][y2] = c;
  }

  _clearStage3Input() {
    this.selected = null;
    this.moveInProgress = false;
  }

  _resetStage3Context() {
    this.selected = null;
    this.moveInProgress = false;
    this.needRelieve = false;
    this.relievePlayer = null;
  }

  _resetStage3Counters() {
    this.pendingCapture = 0;
    this.pendingCapturer = 0;
    this.pendingVictim = 0;
  }

  _endGame(loserColor, reason) {
    if (this.over) return;
    this.over = true;
    this.winner = -loserColor;
    this.loseReason = reason;
    this.stage = 4;
  }

  _forceEndGame(loserColor, reason) {
    this._endGame(loserColor, reason);
    this.capturePlan = [];
    this.captureIndex = Infinity;
    this.pendingCapture = 0;
    this.selfbreakMode = null;
    this._resetStage3Context();
  }

  _endDraw(reason) {
    if (this.over) return;
    this.over = true;
    this.winner = null;
    this.loseReason = reason;
    this.stage = 4;
  }

  // ========== æ–°å¢ï¼šç¼ºå¤±çš„å…³é”®æ–¹æ³• ==========
  _hasAnyLegalMove(color) {
    for (let x = 0; x < SIZE; x++) {
      for (let y = 0; y < SIZE; y++) {
        if (this.board[x][y] === color && this._canMove(x, y)) {
          return true;
        }
      }
    }
    return false;
  }

  _currentCaptureTask() {
    while (
      this.captureIndex < this.capturePlan.length &&
      this.capturePlan[this.captureIndex].left === 0
    ) {
      this.captureIndex++;
    }
    if (this.captureIndex >= this.capturePlan.length) return null;
    return this.capturePlan[this.captureIndex];
  }

  _advanceStage2IfDone() {
    const next = this._currentCaptureTask();
    if (!next) {
      this.stage = 3;
      this.turn = WHITE;
      return true;
    }
    this.turn = next.capturer;
    return false;
  }

  _onStage3TurnEnd(move, moverColor) {
    this.noCaptureCounter++;
    if (this.noCaptureCounter >= 30) {
      this._endDraw("30æ­¥æœªåƒå­");
      return true;
    }
    this._checkSingleLoop(move, moverColor);
    if (this.loopInfo[BLACK].ok && this.loopInfo[WHITE].ok) {
      this.loopRepeatCount++;
      if (this.loopRepeatCount >= 5) {
        this._endDraw("åŒæ–¹ä¸å˜ä½œå’Œ");
        return true;
      }
    }
    return false;
  }

  _checkSingleLoop(move, color) {
    const from = move.from.toString();
    const to   = move.to.toString();
    const info = this.loopInfo[color];

    if (!info.a && !info.b) {
      info.a = move.from;
      info.b = move.to;
      info.ok = true;
      return;
    }

    const a = info.a.toString();
    const b = info.b.toString();

    const valid =
      (from === a && to === b) ||
      (from === b && to === a);

    if (!valid) {
      info.a = null;
      info.b = null;
      info.ok = false;
      return;
    }

    info.ok = true;
  }

  _clearRelieveCache() {
    // çº¯é€»è¾‘ç‰ˆæ— éœ€ç¼“å­˜ï¼Œç•™ç©ºå³å¯
  }

  // ========== å¯¹å¤–ç»Ÿä¸€å…¥å£ ==========
  handleClick(x, y) {
    if (this.over || this.stage === 4) return false;

    if (this.needRelieve) {
      return this._handleStage3Move(x, y);
    }
    if (this.selfbreakMode) {
      return this._handleSelfbreakClick(x, y);
    }
    if (this.stage === 1) return this._handleStage1Place(x, y);
    if (this.stage === 2) return this._handleStage2Capture(x, y);
    if (this.stage === 3) return this._handleStage3Move(x, y);
    return false;
  }

  // ========== é˜¶æ®µ1ï¼šè½å­ ==========
  _handleStage1Place(x, y) {
    const mover = this.turn;
    if (this.board[x][y] !== EMPTY) return false;

    const before = this.enumeratePatterns(mover);
    this.board[x][y] = mover;
    const after = this.enumeratePatterns(mover);
    const { reward: rawReward } = this.newPatternsAndReward(before, after);
    const allowReward = !this.placeRewardLocked;
    const reward = allowReward ? rawReward : (rawReward > 0 ? 1 : 0);
    if (allowReward && reward > 0) this.placeRewardLocked = true;

    this.placeRemaining = this.placeRemaining - 1 + reward;

    if (this.boardFull()) {
      this.stage = 2;
      this.turn = WHITE;
      this.placeRewardLocked = false;
      return true;
    }

    if (this.placeRemaining > 0) {
      return true;
    }

    this.turn = -this.turn;
    this.placeRemaining = 1;
    this.placeRewardLocked = false;
    return true;
  }

  // ========== é˜¶æ®µ2ï¼šåƒå­ ==========
  _handleStage2Capture(x, y) {
    const task = this._currentCaptureTask();
    if (!task) {
      this._advanceStage2IfDone();
      return true;
    }
    const { capturer, victim } = task;

    if (this.countPieces(victim) === 0) {
      this._endGame(victim, "æ£‹å­è¢«æ‘˜é™¤å…‰");
      return true;
    }

    const idle = this.idlePositions(victim);
    if (idle.length === 0) {
      this._requestSelfbreak(victim, capturer, true);
      return true;
    }

    if (this.board[x][y] !== victim) return false;
    const isIdle = idle.some(([ix, iy]) => ix === x && iy === y);
    if (!isIdle) return false;

    this.board[x][y] = EMPTY;
    task.left -= 1;

    if (this.countPieces(victim) === 0) {
      this._endGame(victim, "æ£‹å­è¢«æ‘˜é™¤å…‰");
      return true;
    }

    if (task.left <= 0) {
      this._advanceStage2IfDone();
      return true;
    }

    const idle2 = this.idlePositions(victim);
    if (idle2.length === 0) {
      this._requestSelfbreak(victim, capturer, true);
      return true;
    }

    return true;
  }

  // ========== é˜¶æ®µ3ï¼šèµ°æ£‹ ==========
  _handleStage3Move(x, y) {
    if (this.countPieces(BLACK) === 0) {
      this._endGame(BLACK, "æ£‹å­è¢«æ‘˜é™¤å…‰");
      return true;
    }
    if (this.countPieces(WHITE) === 0) {
      this._endGame(WHITE, "æ£‹å­è¢«æ‘˜é™¤å…‰");
      return true;
    }

    if (this.pendingCapture > 0) {
      return this._handlePendingCapture(x, y);
    }

    const mover = this.turn;
    const opp = -mover;
    if (!this.needRelieve && !this._hasAnyLegalMove(opp)) {
      this.needRelieve = true;
      this.relievePlayer = mover;
      this.turn = mover;
      return true;
    }

    if (!this.selected) {
      if (this.board[x][y] !== mover) return false;
      if (this.needRelieve) {
        const { candidates } = this._getRelieveAllowedPieces(mover);
        if (!candidates.some(([ax, ay]) => ax === x && ay === y)) return false;
      }
      this.selected = { x, y };
      return true;
    }

    if (this.board[x][y] === mover) {
      if (this.needRelieve) {
        const { candidates } = this._getRelieveAllowedPieces(mover);
        if (!candidates.some(([ax, ay]) => ax === x && ay === y)) return false;
      }
      this.selected = { x, y };
      return true;
    }

    const { x: sx, y: sy } = this.selected;
    const manhattan = Math.abs(sx - x) + Math.abs(sy - y);
    if (this.board[x][y] !== EMPTY || manhattan !== 1) {
      this._clearStage3Input();
      return false;
    }

    const before = this.enumeratePatterns(mover);
    const tmpBoard = this.board.map(r => r.slice());
    this._applyMove(sx, sy, x, y);
    const after = this.enumeratePatterns(mover);
    const { newOnes, reward } = this.newPatternsAndReward(before, after);

    if (reward > 0 && this.moveForbiddenBySelfbreak(mover, newOnes)) {
      this.board = tmpBoard;
      this._clearStage3Input();
      return false;
    }

    this._clearStage3Input();
    this._clearRelieveCache();

    if (reward > 0) {
      this._resetStage3Context();
      this.pendingCapture = reward;
      this.pendingCapturer = mover;
      this.pendingVictim = opp;
      this.turn = mover;
      return true;
    }

    const move = { from: [sx, sy], to: [x, y] };
    if (this._onStage3TurnEnd(move, mover)) {
      return true;
    }

    if (this.needRelieve) {
      if (this.legalMoves(opp).length > 0) {
        this._endRelieve();
      }
    }

    if (this.needRelieve) {
      this.turn = mover;
    } else {
      this.turn = opp;
    }
    return true;
  }

  // ========== æˆé˜µååƒå­ ==========
  _handlePendingCapture(x, y) {
    const capturer = this.pendingCapturer;
    const victim = this.pendingVictim;

    if (this.countPieces(victim) === 0) {
      this._forceEndGame(victim, "æ£‹å­è¢«æ‘˜é™¤å…‰");
      return true;
    }

    const idle = this.idlePositions(victim);
    if (idle.length === 0) {
      this._requestSelfbreak(victim, capturer, false);
      return true;
    }

    if (this.board[x][y] !== victim) return false;
    const isIdle = idle.some(([ix, iy]) => ix === x && iy === y);
    if (!isIdle) return false;

    this.board[x][y] = EMPTY;

    if (this.countPieces(victim) === 0) {
      this._forceEndGame(victim, "æ£‹å­è¢«æ‘˜é™¤å…‰");
      return true;
    }

    this.pendingCapture -= 1;

    if (this.pendingCapture > 0) {
      const idle2 = this.idlePositions(victim);
      if (idle2.length === 0) {
        this._requestSelfbreak(victim, capturer, false);
        return true;
      }
      return true;
    }

    this._resetStage3Counters();

    if (this.legalMoves(victim).length === 0) {
      this.needRelieve = true;
      this.turn = capturer;
      return true;
    }

    this.turn = victim;
    return true;
  }

  // ========== è‡ªæ‹†ç‚¹å‡» ==========
  _handleSelfbreakClick(x, y) {
    const m = this.selfbreakMode;
    if (!m) return false;
    const { victim, returnTo, countTowardStage2 } = m;

    if (this.board[x][y] !== victim) return false;
    const members = this.patternMembers(victim);
    if (!members.has(`${x},${y}`)) return false;

    this.board[x][y] = EMPTY;
    this.recentSelfbreakEmpty[victim].add(`${x},${y}`);

    if (countTowardStage2 && this.stage === 2) {
      const task = this._currentCaptureTask();
      if (task && task.victim === victim && task.left > 0) {
        task.left -= 1;
        if (task.left <= 0) {
          this.selfbreakMode = null;
          this._advanceStage2IfDone();
          return true;
        }
      }
    }

    if (
      !countTowardStage2 &&
      this.stage === 3 &&
      this.pendingCapture > 0 &&
      this.pendingVictim === victim &&
      this.pendingCapturer === returnTo
    ) {
      this.pendingCapture -= 1;
      if (this.pendingCapture <= 0) {
        this.selfbreakMode = null;
        if (this.countPieces(victim) === 0) {
          this._endGame(victim, "æ£‹å­è¢«æ‘˜é™¤å…‰");
          return true;
        }
        if (this.legalMoves(victim).length === 0) {
          this.needRelieve = true;
          this.turn = returnTo;
          return true;
        }
        this.turn = victim;
        return true;
      }
    }

    if (this.idlePositions(victim).length === 0) {
      return true;
    }

    this.selfbreakMode = null;
    this.turn = returnTo;
    return true;
  }

  _requestSelfbreak(victimColor, returnToColor, countTowardStage2 = false) {
    this.selfbreakMode = {
      victim: victimColor,
      returnTo: returnToColor,
      countTowardStage2,
    };
  }

  _doSelfBreakUntilIdle(victimColor, countTowardStage2 = false, returnToColor = null) {
    // çº¯é€»è¾‘ç‰ˆä¸æ‰§è¡Œ AI è‡ªæ‹†ï¼Œä»…è®¾ç½® selfbreakMode
    this._requestSelfbreak(victimColor, returnToColor, countTowardStage2);
  }

  // æ”¾æ´»ç›¸å…³
  _getRelieveDistanceMap(relieverColor, victimColor) {
    const dist = new Map();
    const q = [];
    for (let x = 0; x < SIZE; x++) {
      for (let y = 0; y < SIZE; y++) {
        if (this.board[x][y] === victimColor) {
          const k = `${x},${y}`;
          dist.set(k, 0);
          q.push([x, y]);
        }
      }
    }
    while (q.length) {
      const [x, y] = q.shift();
      const d = dist.get(`${x},${y}`);
      for (const [dx, dy] of DIR4) {
        const nx = x + dx, ny = y + dy;
        if (!this.inBounds(nx, ny)) continue;
        const v = this.board[nx][ny];
        if (v !== relieverColor) continue;
        const k2 = `${nx},${ny}`;
        if (dist.has(k2)) continue;
        dist.set(k2, d + 1);
        q.push([nx, ny]);
      }
    }
    return dist;
  }

  _getRelieveAllowedPieces(relieverColor) {
    const victim = -relieverColor;
    const distMap = this._getRelieveDistanceMap(relieverColor, victim);
    const layers = new Map();
    for (let x = 0; x < SIZE; x++) {
      for (let y = 0; y < SIZE; y++) {
        if (this.board[x][y] !== relieverColor) continue;
        const k = `${x},${y}`;
        if (!distMap.has(k)) continue;
        const d = distMap.get(k);
        if (!layers.has(d)) layers.set(d, []);
        layers.get(d).push([x, y]);
      }
    }
    const dists = Array.from(layers.keys()).sort((a, b) => a - b);
    for (const d of dists) {
      const layer = layers.get(d);
      const movable = layer.filter(([x, y]) => this._canMove(x, y));
      if (movable.length > 0) {
        return { minDist: d, candidates: movable };
      }
    }
    return { minDist: Infinity, candidates: [] };
  }

  _endRelieve() {
    this.needRelieve = false;
    this.relievePlayer = null;
    this.selected = null;
    this.moveInProgress = false;
  }

  // ========== çŠ¶æ€å¯¼å‡º ==========
  exportState() {
    return {
      board: this.board.map(r => r.slice()),
      stage: this.stage,
      turn: this.turn,
      over: this.over,
      winner: this.winner,
      loseReason: this.loseReason,
      placeRemaining: this.placeRemaining,
      placeRewardLocked: this.placeRewardLocked,
      capturePlan: this.capturePlan.map(cp => ({...cp})),
      captureIndex: this.captureIndex,
      pendingCapture: this.pendingCapture,
      pendingCapturer: this.pendingCapturer,
      pendingVictim: this.pendingVictim,
      needRelieve: this.needRelieve,
      relievePlayer: this.relievePlayer,
      selfbreakMode: this.selfbreakMode ? {...this.selfbreakMode} : null,
      recentSelfbreakEmpty: {
        [BLACK]: [...this.recentSelfbreakEmpty[BLACK]],
        [WHITE]: [...this.recentSelfbreakEmpty[WHITE]],
      },
      drawOffer: this.drawOffer,
      noCaptureCounter: this.noCaptureCounter,
      loopInfo: {
        [BLACK]: {
          a: this.loopInfo[BLACK].a ? [...this.loopInfo[BLACK].a] : null,
          b: this.loopInfo[BLACK].b ? [...this.loopInfo[BLACK].b] : null,
          ok: this.loopInfo[BLACK].ok
        },
        [WHITE]: {
          a: this.loopInfo[WHITE].a ? [...this.loopInfo[WHITE].a] : null,
          b: this.loopInfo[WHITE].b ? [...this.loopInfo[WHITE].b] : null,
          ok: this.loopInfo[WHITE].ok
        }
      },
      loopRepeatCount: this.loopRepeatCount,
      humanColor: this.humanColor,
    };
  }

  static fromState(state) {
    const game = new DafangGameCore(state.humanColor);
    game.board = state.board.map(r => r.slice());
    game.stage = state.stage;
    game.turn = state.turn;
    game.over = state.over;
    game.winner = state.winner;
    game.loseReason = state.loseReason;
    game.placeRemaining = state.placeRemaining;
    game.placeRewardLocked = state.placeRewardLocked;
    game.capturePlan = state.capturePlan.map(cp => ({...cp}));
    game.captureIndex = state.captureIndex;
    game.pendingCapture = state.pendingCapture;
    game.pendingCapturer = state.pendingCapturer;
    game.pendingVictim = state.pendingVictim;
    game.needRelieve = state.needRelieve;
    game.relievePlayer = state.relievePlayer;
    game.selfbreakMode = state.selfbreakMode ? {...state.selfbreakMode} : null;
    game.recentSelfbreakEmpty = {
      [BLACK]: new Set(state.recentSelfbreakEmpty[BLACK]),
      [WHITE]: new Set(state.recentSelfbreakEmpty[WHITE]),
    };
    game.drawOffer = state.drawOffer;
    game.noCaptureCounter = state.noCaptureCounter;
    game.loopInfo = {
      [BLACK]: {
        a: state.loopInfo[BLACK].a ? [...state.loopInfo[BLACK].a] : null,
        b: state.loopInfo[BLACK].b ? [...state.loopInfo[BLACK].b] : null,
        ok: Boolean(state.loopInfo[BLACK].ok)
      },
      [WHITE]: {
        a: state.loopInfo[WHITE].a ? [...state.loopInfo[WHITE].a] : null,
        b: state.loopInfo[WHITE].b ? [...state.loopInfo[WHITE].b] : null,
        ok: Boolean(state.loopInfo[WHITE].ok)
      }
    };
    game.loopRepeatCount = state.loopRepeatCount;
    return game;
  }

  stageText() {
    if (this.stage === 1) return "ç¬¬ä¸€é˜¶æ®µï¼šè½å­";
    if (this.stage === 2) return "ç¬¬äºŒé˜¶æ®µï¼šåƒå­";
    if (this.stage === 3) return "ç¬¬ä¸‰é˜¶æ®µï¼šèµ°æ£‹";
    return "ç»ˆå±€";
  }

  actionHint() {
    if (this.over) return "å¯¹å±€å·²ç»“æŸã€‚";
    if (this.selfbreakMode) {
      const { victim } = this.selfbreakMode;
      return `éœ€è¦è‡ªæ‹†ï¼šè¯· ${colorName(victim)} ç‚¹å‡»è‡ªå·±çš„é˜µå‹å­è‡ªæ‹†ã€‚`;
    }
    if (this.stage === 1) {
      return `è½å­ä¸­ã€‚æœ¬æ–¹è¿˜å¯è½å­ï¼š${this.placeRemaining} æ¬¡ã€‚`;
    }
    if (this.stage === 2) {
      const t = this._currentCaptureTask();
      if (!t) return "åƒå­å®Œæ¯•ï¼Œå‡†å¤‡è¿›å…¥èµ°æ£‹ã€‚";
      return `${colorName(t.capturer)} åƒ ${colorName(t.victim)}ï¼Œè¿˜éœ€åƒ ${t.left} ä¸ªã€‚`;
    }
    if (this.stage === 3) {
      if (this.pendingCapture > 0) {
        return `å› æˆé˜µåƒå­ï¼šè¿˜éœ€åƒ ${this.pendingCapture} ä¸ª ${colorName(this.pendingVictim)} é—²å­ã€‚`;
      }
      if (this.needRelieve) {
        return `æ”¾æ´»ï¼šå¿…é¡»å†èµ°ä¸€æ­¥è®©å¯¹æ–¹å¯åŠ¨ã€‚`;
      }
      return `èµ°æ£‹ä¸­ï¼šå…ˆé€‰æ£‹å­ï¼Œå†ç‚¹å››é‚»æ¥ç©ºä½ã€‚`;
    }
    return "ç»ˆå±€ã€‚";
  }

  _log(s) { this.log.push(s); }

  resign(color) {
    if (this.over) return;
    this._endGame(color, "è®¤è¾“");
  }
}

// ========== å‰ç«¯çŠ¶æ€ ==========
let socket = null;
let role = 'spectator'; // 'player' or 'spectator'
let localColor = null;
let roomId = null;
let game = null;
let heartbeatInterval = null;
let rematchRequested = false;
const ctx = document.getElementById('cv').getContext('2d');

// ========== å¿ƒè·³ä¿æ´» ==========
function startHeartbeat() {
  if (heartbeatInterval) clearInterval(heartbeatInterval);
  heartbeatInterval = setInterval(() => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: 'ping' }));
    }
  }, 5 * 60 * 1000); // æ¯5åˆ†é’Ÿä¸€æ¬¡
}

function stopHeartbeat() {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
  }
}

// ========== ç»˜åˆ¶ç©ºæ£‹ç›˜ ==========
function drawEmptyBoard() {
  const pad = 60, span = (600 - 2*pad)/5;
  ctx.clearRect(0, 0, 600, 600);
  for (let i = 0; i < 6; i++) {
    ctx.beginPath();
    ctx.moveTo(pad, pad + i * span);
    ctx.lineTo(pad + 5 * span, pad + i * span);
    ctx.moveTo(pad + i * span, pad);
    ctx.lineTo(pad + i * span, pad + 5 * span);
    ctx.stroke();
  }
}

// ========== è¿æ¥é€»è¾‘ ==========
const WORKER_URL = 'wss://www.dafangqi.eu.cc';

function connectToRoom(id, asSpectator = false) {
  if (socket) socket.close();
  roomId = id;
  socket = new WebSocket(`${WORKER_URL}/game/${roomId}`);
  
  socket.onopen = () => {
    document.getElementById('connStatus').textContent = 'å·²è¿æ¥';
    document.getElementById('roomText').textContent = roomId;
    socket.send(JSON.stringify({ type: 'join', asSpectator }));
    startHeartbeat();
  };
  
  socket.onmessage = (e) => handleServerMsg(JSON.parse(e.data));
  socket.onclose = () => {
    document.getElementById('connStatus').textContent = 'æ–­å¼€';
    document.getElementById('roomText').textContent = '-';
    stopHeartbeat();
    socket = null;
  };
}

// å¿«é€Ÿå¯¹æˆ˜ï¼šè¿æ¥åˆ°åŒ¹é…ç«¯ç‚¹
document.getElementById('btnQuickMatch').onclick = () => {
  if (socket) socket.close();
  socket = new WebSocket(`${WORKER_URL}/match`);
  
  socket.onopen = () => {
    document.getElementById('connStatus').textContent = 'åŒ¹é…ä¸­...';
  };
  
  socket.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    if (msg.type === 'match_success') {
      // åŒ¹é…æˆåŠŸï¼ŒåŠ å…¥æŒ‡å®šæˆ¿é—´
      connectToRoom(msg.roomId, false);
    } else {
      handleServerMsg(msg);
    }
  };
  
  socket.onclose = () => {
    document.getElementById('connStatus').textContent = 'æ–­å¼€';
    stopHeartbeat();
    socket = null;
  };
};

document.getElementById('btnCreateRoom').onclick = () => {
  const id = String(Math.floor(Math.random() * 9000) + 1000); // 1000-9999
  connectToRoom(id, false);
  alert(`æˆ¿é—´å·²åˆ›å»º\næˆ¿é—´å·: ${id}\nè¯·åˆ†äº«ç»™å¯¹æ‰‹`);
};

document.getElementById('btnJoinRoom').onclick = () => {
  const id = document.getElementById('roomIdInput').value.trim();
  if (/^\d{4}$/.test(id)) {
    connectToRoom(id, false);
  } else {
    alert('è¯·è¾“å…¥4ä½æ•°å­—æˆ¿é—´å·');
  }
};

document.getElementById('btnSpectate').onclick = () => {
  const id = document.getElementById('roomIdInput').value.trim();
  if (/^\d{4}$/.test(id)) {
    connectToRoom(id, true);
  } else {
    alert('è¯·è¾“å…¥4ä½æ•°å­—æˆ¿é—´å·');
  }
};

// ========== å†æ¥ä¸€å±€ ==========
document.getElementById('btnRematch').onclick = () => {
  if (!game || !game.over || !socket) return;
  if (rematchRequested) return;
  rematchRequested = true;
  socket.send(JSON.stringify({ type: 'rematch_request' }));
  log('ä½ è¯·æ±‚å†æ¥ä¸€å±€...');
};

function showRematchDialog() {
  if (!confirm('å¯¹æ–¹è¯·æ±‚å†æ¥ä¸€å±€ï¼Œæ˜¯å¦åŒæ„ï¼Ÿ')) {
    socket.send(JSON.stringify({ type: 'rematch_reject' }));
    log('ä½ æ‹’ç»äº†å†æ¥ä¸€å±€');
  } else {
    socket.send(JSON.stringify({ type: 'rematch_accept' }));
    log('åŒæ–¹åŒæ„å†æ¥ä¸€å±€');
  }
}

// ========== æ¶ˆæ¯å¤„ç† ==========
function handleServerMsg(msg) {
  if (msg.type === 'assign_role') {
    role = msg.role;
    localColor = msg.color;
    document.getElementById('roleText').textContent = 
      role === 'spectator' ? 'è§‚æˆ˜è€…' : 
      (localColor === BLACK ? 'é»‘æ–¹ç©å®¶' : 'ç™½æ–¹ç©å®¶');
    game = new DafangGameCore(localColor);
    render();
  }
  else if (msg.type === 'sync_state') {
    game = DafangGameCore.fromState(msg.state);
    render();
    if (msg.move) {
      game._log(`${colorName(msg.move.by)} è½å­ (${msg.move.x},${msg.move.y})`);
    }
  }
  else if (msg.type === 'game_over') {
    const winner = msg.winner === null ? 'å’Œæ£‹' : 
                   msg.winner === 1 ? 'é»‘æ–¹èƒœ' : 'ç™½æ–¹èƒœ';
    game._log(`ğŸ ${winner} â€”â€” ${msg.reason}`);
    render();
    rematchRequested = false;
  }
  else if (msg.type === 'rematch_request') {
    showRematchDialog();
  }
  else if (msg.type === 'rematch_start') {
    game = new DafangGameCore(localColor);
    render();
    log('æ–°å±€å¼€å§‹ï¼');
  }
}

// ========== ç”¨æˆ·æ“ä½œ ==========
function canvasClick(e) {
  // âœ… å…³é”®ï¼šæ£€æŸ¥è¿æ¥æ˜¯å¦æœ‰æ•ˆ
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    alert("è¿æ¥å·²æ–­å¼€ï¼Œè¯·åˆ·æ–°é¡µé¢é‡æ–°åŠ å…¥æˆ¿é—´");
    return;
  }

  if (role !== 'player' || !game || game.over || game.turn !== localColor) return;
  const rect = e.target.getBoundingClientRect();
  const x = Math.floor((e.clientY - rect.top) / (rect.height / 6));
  const y = Math.floor((e.clientX - rect.left) / (rect.width / 6));
  socket.send(JSON.stringify({ type: 'move', x, y }));
}
document.getElementById('cv').addEventListener('click', canvasClick);

document.getElementById('btnResign').onclick = () => {
  if (role !== 'player' || !game || game.over) return;
  game.resign(localColor);
  socket.send(JSON.stringify({ type: 'resign' }));
  render();
};

// ========== æ¸²æŸ“ & æ—¥å¿— ==========
function render() {
  const pad = 60, span = (600 - 2*pad)/5;
  ctx.clearRect(0, 0, 600, 600);
  for (let i = 0; i < 6; i++) {
    ctx.beginPath();
    ctx.moveTo(pad, pad + i * span);
    ctx.lineTo(pad + 5 * span, pad + i * span);
    ctx.moveTo(pad + i * span, pad);
    ctx.lineTo(pad + i * span, pad + 5 * span);
    ctx.stroke();
  }
  for (let x = 0; x < 6; x++) {
    for (let y = 0; y < 6; y++) {
      const v = game.board[x][y];
      if (v !== 0) {
        ctx.beginPath();
        ctx.arc(pad + y * span, pad + x * span, 20, 0, Math.PI * 2);
        ctx.fillStyle = v === 1 ? 'black' : 'white';
        ctx.fill();
        ctx.stroke();
      }
    }
  }
  document.getElementById('stageText').textContent = game.stageText();
  document.getElementById('actionHint').textContent = game.actionHint();
  document.getElementById('turnText').textContent = game.over ? '-' : colorName(game.turn);
  document.getElementById('humanColorText').textContent = 
    role === 'spectator' ? 'è§‚æˆ˜' : `${colorName(localColor)}ï¼ˆ${localColor === BLACK ? "å…ˆæ‰‹" : "åæ‰‹"}ï¼‰`;
  const forb = Array.from(game.recentSelfbreakEmpty[game.turn] || []);
  document.getElementById('forbiddenText').textContent = forb.length ? forb.join("  ") : "ï¼ˆæ— ï¼‰";
  
  const el = document.getElementById('log');
  el.textContent = game.log.slice(-200).join('\n');
  el.scrollTop = el.scrollHeight;
}

function log(msg) {
  const el = document.getElementById('log');
  el.textContent += msg + '\n';
  el.scrollTop = el.scrollHeight;
}

// ========== åˆå§‹åŒ– ==========
drawEmptyBoard();
</script>
</body>
</html>
