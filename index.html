<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>å¤§æ–¹æ£‹ Â· è¿çº¿å¯¹æˆ˜</title>
<style>
:root {
--bg: #0f172a;
--text: #e5e7eb;
--muted: #94a3b8;
--wood1: #f6deb7;
--wood2: #efd1a1;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  background: radial-gradient(1200px 600px at 20% 0%, #1f2937, var(--bg));
  color: var(--text);
  padding: 16px;
}
.wrap {
  max-width: 1100px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: 1.3fr 1fr;
  gap: 16px;
}
.card {
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 14px;
  padding: 14px;
  box-shadow: 0 10px 25px rgba(0,0,0,0.25);
}
h1 {
  font-size: 18px;
  margin: 0 0 10px 0;
  letter-spacing: 0.5px;
}
.appTitle {
  text-align: center;
  margin: 0 0 10px 0;
}
.row {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items: center;
}
button,
input {
  background: rgba(255,255,255,0.07);
  border: 1px solid rgba(255,255,255,0.12);
  color: var(--text);
  padding: 8px 10px;
  border-radius: 10px;
  cursor: pointer;
}
input {
  background: #1e293b;
  width: 120px;
  font-size: 14px;
}
button:hover {
  border-color: rgba(255,255,255,0.22);
}
button.primary {
  background: rgba(34,197,94,0.18);
  border-color: rgba(34,197,94,0.35);
}
button.danger {
  background: rgba(239,68,68,0.18);
  border-color: rgba(239,68,68,0.35);
}
.badge {
  display: inline-flex;
  align-items: center;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.18);
  font-size: 12px;
  color: var(--muted);
  gap: 6px;
}
.badge strong {
  color: var(--text);
}
.log {
  background: rgba(0,0,0,0.25);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 12px;
  padding: 10px;
  height: 340px;
  overflow: auto;
  font-size: 12px;
  line-height: 1.45;
  white-space: pre-wrap;
}
canvas {
  width: 520px;
  height: 520px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 16px;
  background: repeating-linear-gradient(90deg,
    rgba(255,255,255,0.12) 0px,
    rgba(255,255,255,0.12) 1px,
    rgba(255,255,255,0) 6px,
    rgba(255,255,255,0) 22px),
    repeating-linear-gradient(0deg,
    rgba(0,0,0,0.04) 0px,
    rgba(0,0,0,0.04) 2px,
    rgba(0,0,0,0) 14px,
    rgba(0,0,0,0) 28px),
    linear-gradient(180deg, var(--wood1), var(--wood2));
}
.kpi {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin-top: 10px;
}
.kpi .box {
  background: rgba(0,0,0,0.2);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 12px;
  padding: 10px;
  font-size: 12px;
}
.box .label {
  color: var(--muted);
  margin-bottom: 4px;
}
.box .val {
  font-size: 14px;
}
.hint {
  font-size: 12px;
  color: var(--muted);
  margin-top: 8px;
  line-height: 1.5;
}
.boardActions {
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 8px;
}
.boardActions button {
  font-size: 14px;
  padding: 6px 10px;
  border-radius: 10px;
}
@media (max-width: 860px) {
  .wrap { grid-template-columns: 1fr; }
  canvas { width: min(92vw, 640px); height: auto; }
}
@media (max-width: 420px) {
  .row { grid-template-columns: 1fr; }
  button, input { width: 100%; }
}
</style>
</head>
<body>
<div class="wrap">
  <div class="card boardCard">
    <h1 class="appTitle">å¤§æ–¹æ£‹ Â· è¿çº¿å¯¹æˆ˜</h1>
    <canvas id="cv" width="600" height="600"></canvas>
    <div class="boardActions">
      <button class="primary" id="btnQuickMatch">å¿«é€Ÿå¯¹æˆ˜</button>
      <button id="btnCreateRoom">åˆ›å»ºæˆ¿é—´</button>
      <input id="roomIdInput" placeholder="æˆ¿é—´å·ï¼ˆ4ä½æ•°å­—ï¼‰">
      <button id="btnJoinRoom">åŠ å…¥æˆ¿é—´</button>
      <button id="btnSpectate">è§‚æˆ˜</button>
      <button id="btnRematch">å†æ¥ä¸€å±€</button>
      <button class="danger" id="btnResign">è®¤è¾“</button>
    </div>
  </div>

  <div class="card infoCard">
    <div class="row topbar">
      <span class="badge">çŠ¶æ€ <strong id="connStatus">æœªè¿æ¥</strong></span>
      <span class="badge">è§’è‰² <strong id="roleText">-</strong></span>
      <span class="badge">æˆ¿é—´ <strong id="roomText">-</strong></span>
    </div>
    <div class="kpi">
      <div class="box">
        <div class="label">é˜¶æ®µ / å½“å‰è¡ŒåŠ¨</div>
        <div class="val" id="stageText">-</div>
        <div class="hint" id="actionHint">-</div>
      </div>
      <div class="box">
        <div class="label">ä½ æ‰§</div>
        <div class="val" id="humanColorText">-</div>
        <div class="hint">è½®åˆ°ï¼š<span id="turnText">-</span></div>
      </div>
      <div class="box">
        <div class="label">è¢«è‡ªæ‹†è®©å‡ºçš„ç©ºä½</div>
        <div class="val mono" id="forbiddenText">-</div>
      </div>
    </div>
    <div class="hint">
      ğŸ’¡ å¿«é€Ÿå¯¹æˆ˜ï¼šåŒ¹é…é™Œç”Ÿäºº<br>
      ğŸ‘¥ åˆ›å»ºæˆ¿é—´ï¼šç”Ÿæˆ4ä½æ•°å­—æˆ¿é—´å·ï¼Œåˆ†äº«ç»™æœ‹å‹
    </div>
  </div>

  <div class="card bottomCard">
    <h1>å¯¹å±€æ—¥å¿—</h1>
    <div class="log" id="log"></div>
    <h1 style="margin-top: 12px">è¡Œæ£‹è§„åˆ™</h1>
    <div class="hint">
      6Ã—6 äº¤å‰ç‚¹ã€‚èµ°æ£‹ä»…å››é‚»æ¥ï¼›å¥–åŠ±=æœ¬æ¬¡åŠ¨ä½œæ–°å½¢æˆé˜µå‹ï¼ˆå¤åˆç´¯åŠ ï¼‰ã€‚<br>
      ç¬¬äºŒé˜¶æ®µï¼šåƒå­é¢åº¦=2ï¼ˆè¢«åƒæ–¹è‡ªæ‹†è®©å‡ºçš„é˜µå‹å­ä¹Ÿè®¡å…¥é¢åº¦ï¼‰ã€‚<br>
      âœ… è§„åˆ™æ ¡æ­£ï¼šè¾¹çº¿è¡Œ/åˆ—å½¢æˆçš„â€œé¾™â€ä¸ç®—é˜µå‹ã€ä¸å¥–åŠ±ã€‚
    </div>
  </div>
</div>

<script>
// ========== å¸¸é‡ ==========
const EMPTY = 0, BLACK = 1, WHITE = -1, SIZE = 6;
const DIR4 = [[-1,0],[1,0],[0,-1],[0,1]];
function colorName(c) { return c === BLACK ? "é»‘â—" : "ç™½â—‹"; }
function isBorder(x, y) { return x===0||x===SIZE-1||y===0||y===SIZE-1; }

// ========== æ¸¸æˆæ ¸å¿ƒï¼ˆçº¯é€»è¾‘ï¼‰==========
class DafangGameCore {
  constructor(humanColor) {
    this.humanColor = humanColor;
    this.aiColor = 0;
    this.board = Array.from({length:SIZE}, () => Array(SIZE).fill(EMPTY));
    this.stage = 1;
    this.turn = BLACK;
    this.over = false;
    this.winner = null;
    this.loseReason = "";
    this.placeRemaining = 1;
    this.placeRewardLocked = false;
    this.capturePlan = [
      {capturer:WHITE, victim:BLACK, left:2},
      {capturer:BLACK, victim:WHITE, left:2}
    ];
    this.captureIndex = 0;
    this.pendingCapture = 0;
    this.pendingCapturer = 0;
    this.pendingVictim = 0;
    this.needRelieve = false;
    this.relievePlayer = null;
    this.selfbreakMode = null;
    this.selected = null;
    this.moveInProgress = false;
    this.recentSelfbreakEmpty = {[BLACK]:new Set(),[WHITE]:new Set()};
    this.log = [];
  }

  // ========== å·¥å…·å‡½æ•°ï¼ˆç•¥ï¼Œå®é™…éœ€è¡¥å…¨ï¼‰==========
  inBounds(x, y) { return x >= 0 && x < SIZE && y >= 0 && y < SIZE; }
  countPieces(color) {
    let n = 0;
    for (let x = 0; x < SIZE; x++)
      for (let y = 0; y < SIZE; y++)
        if (this.board[x][y] === color) n++;
    return n;
  }
  _canMove(x, y) {
    for (const [dx, dy] of DIR4) {
      const nx = x + dx, ny = y + dy;
      if (this.inBounds(nx, ny) && this.board[nx][ny] === EMPTY) return true;
    }
    return false;
  }
  legalMoves(color) {
    const moves = [];
    for (let x = 0; x < SIZE; x++) {
      for (let y = 0; y < SIZE; y++) {
        if (this.board[x][y] !== color) continue;
        for (const [dx, dy] of DIR4) {
          const nx = x + dx, ny = y + dy;
          if (this.inBounds(nx, ny) && this.board[nx][ny] === EMPTY)
            moves.push([x, y, nx, ny]);
        }
      }
    }
    return moves;
  }
  enumeratePatterns(color) { /* ç•¥ */ }
  _patKey(kind, cells) { /* ç•¥ */ }
  _patParse(key) { /* ç•¥ */ }
  newPatternsAndReward(beforeSet, afterSet) { /* ç•¥ */ }
  patternMembers(color) { /* ç•¥ */ }
  idlePositions(color) { /* ç•¥ */ }
  moveForbiddenBySelfbreak(color, newPatternKeys) { /* ç•¥ */ }
  _hasAnyLegalMove(color) { /* ç•¥ */ }
  _currentCaptureTask() { /* ç•¥ */ }
  _advanceStage2IfDone() { /* ç•¥ */ }
  _onStage3TurnEnd(move, moverColor) { /* ç•¥ */ }
  _checkSingleLoop(move, color) { /* ç•¥ */ }
  _getRelieveDistanceMap(relieverColor, victimColor) { /* ç•¥ */ }
  _getRelieveAllowedPieces(relieverColor) { /* ç•¥ */ }
  _endRelieve() { /* ç•¥ */ }
  _clearRelieveCache() { /* ç•¥ */ }
  _resetStage3Context() { /* ç•¥ */ }
  _resetStage3Counters() { /* ç•¥ */ }
  _endGame(loserColor, reason) { /* ç•¥ */ }
  _forceEndGame(loserColor, reason) { /* ç•¥ */ }
  _endDraw(reason) { /* ç•¥ */ }
  _applyMove(x1, y1, x2, y2) {
    const c = this.board[x1][y1];
    this.board[x1][y1] = EMPTY;
    this.board[x2][y2] = c;
  }
  _clearStage3Input() {
    this.selected = null;
    this.moveInProgress = false;
  }

  // ========== é˜¶æ®µå¤„ç†ï¼ˆç•¥ï¼‰==========
  _handleStage1Place(x, y) { /* ç•¥ */ }
  _handleStage2Capture(x, y) { /* ç•¥ */ }
  _handleStage3Move(x, y) { /* ç•¥ */ }
  _handlePendingCapture(x, y) { /* ç•¥ */ }
  _handleSelfbreakClick(x, y) { /* ç•¥ */ }
  _requestSelfbreak(victimColor, returnToColor, countTowardStage2 = false) { /* ç•¥ */ }
  _doSelfBreakUntilIdle(victimColor, countTowardStage2, returnToColor) { /* ç•¥ */ }

  handleClick(x, y) {
    if (this.over || this.stage === 4) return false;
    if (this.needRelieve) return this._handleStage3Move(x, y);
    if (this.selfbreakMode) return this._handleSelfbreakClick(x, y);
    if (this.stage === 1) return this._handleStage1Place(x, y);
    if (this.stage === 2) return this._handleStage2Capture(x, y);
    if (this.stage === 3) return this._handleStage3Move(x, y);
    return false;
  }

  stageText() {
    if (this.stage === 1) return "ç¬¬ä¸€é˜¶æ®µï¼šè½å­";
    if (this.stage === 2) return "ç¬¬äºŒé˜¶æ®µï¼šåƒå­";
    if (this.stage === 3) return "ç¬¬ä¸‰é˜¶æ®µï¼šèµ°æ£‹";
    return "ç»ˆå±€";
  }

  actionHint() {
    if (this.over) return "å¯¹å±€å·²ç»“æŸã€‚";
    if (this.selfbreakMode) {
      const { victim } = this.selfbreakMode;
      return `éœ€è¦è‡ªæ‹†ï¼šè¯· ${colorName(victim)} ç‚¹å‡»è‡ªå·±çš„é˜µå‹å­è‡ªæ‹†ã€‚`;
    }
    if (this.stage === 1) {
      return `è½å­ä¸­ã€‚æœ¬æ–¹è¿˜å¯è½å­ï¼š${this.placeRemaining} æ¬¡ã€‚`;
    }
    if (this.stage === 2) {
      const t = this._currentCaptureTask();
      if (!t) return "åƒå­å®Œæ¯•ï¼Œå‡†å¤‡è¿›å…¥èµ°æ£‹ã€‚";
      return `${colorName(t.capturer)} åƒ ${colorName(t.victim)}ï¼Œè¿˜éœ€åƒ ${t.left} ä¸ªã€‚`;
    }
    if (this.stage === 3) {
      if (this.pendingCapture > 0) {
        return `å› æˆé˜µåƒå­ï¼šè¿˜éœ€åƒ ${this.pendingCapture} ä¸ª ${colorName(this.pendingVictim)} é—²å­ã€‚`;
      }
      if (this.needRelieve) {
        return `æ”¾æ´»ï¼šå¿…é¡»å†èµ°ä¸€æ­¥è®©å¯¹æ–¹å¯åŠ¨ã€‚`;
      }
      return `èµ°æ£‹ä¸­ï¼šå…ˆé€‰æ£‹å­ï¼Œå†ç‚¹å››é‚»æ¥ç©ºä½ã€‚`;
    }
    return "ç»ˆå±€ã€‚";
  }

  _log(s) { this.log.push(s); }

  resign(color) {
    if (this.over) return;
    this._endGame(color, "è®¤è¾“");
  }

  // ========== çŠ¶æ€å¯¼å‡º ==========
  exportState() {
    return {
      board: this.board.map(r => r.slice()),
      stage: this.stage,
      turn: this.turn,
      over: this.over,
      winner: this.winner,
      loseReason: this.loseReason,
      placeRemaining: this.placeRemaining,
      placeRewardLocked: this.placeRewardLocked,
      capturePlan: this.capturePlan.map(cp => ({...cp})),
      captureIndex: this.captureIndex,
      pendingCapture: this.pendingCapture,
      pendingCapturer: this.pendingCapturer,
      pendingVictim: this.pendingVictim,
      needRelieve: this.needRelieve,
      relievePlayer: this.relievePlayer,
      selfbreakMode: this.selfbreakMode ? {...this.selfbreakMode} : null,
      recentSelfbreakEmpty: {
        [BLACK]: [...this.recentSelfbreakEmpty[BLACK]],
        [WHITE]: [...this.recentSelfbreakEmpty[WHITE]],
      },
      drawOffer: this.drawOffer,
      noCaptureCounter: this.noCaptureCounter,
      loopInfo: {
        [BLACK]: {
          a: this.loopInfo[BLACK].a ? [...this.loopInfo[BLACK].a] : null,
          b: this.loopInfo[BLACK].b ? [...this.loopInfo[BLACK].b] : null,
          ok: this.loopInfo[BLACK].ok
        },
        [WHITE]: {
          a: this.loopInfo[WHITE].a ? [...this.loopInfo[WHITE].a] : null,
          b: this.loopInfo[WHITE].b ? [...this.loopInfo[WHITE].b] : null,
          ok: this.loopInfo[WHITE].ok
        }
      },
      loopRepeatCount: this.loopRepeatCount,
      humanColor: this.humanColor,
    };
  }

  static fromState(state) {
    const game = new DafangGameCore(state.humanColor);
    game.board = state.board.map(r => r.slice());
    game.stage = state.stage;
    game.turn = state.turn;
    game.over = state.over;
    game.winner = state.winner;
    game.loseReason = state.loseReason;
    game.placeRemaining = state.placeRemaining;
    game.placeRewardLocked = state.placeRewardLocked;
    game.capturePlan = state.capturePlan.map(cp => ({...cp}));
    game.captureIndex = state.captureIndex;
    game.pendingCapture = state.pendingCapture;
    game.pendingCapturer = state.pendingCapturer;
    game.pendingVictim = state.pendingVictim;
    game.needRelieve = state.needRelieve;
    game.relievePlayer = state.relievePlayer;
    game.selfbreakMode = state.selfbreakMode ? {...state.selfbreakMode} : null;
    game.recentSelfbreakEmpty = {
      [BLACK]: new Set(state.recentSelfbreakEmpty[BLACK]),
      [WHITE]: new Set(state.recentSelfbreakEmpty[WHITE]),
    };
    game.drawOffer = state.drawOffer;
    game.noCaptureCounter = state.noCaptureCounter;
    game.loopInfo = {
      [BLACK]: {
        a: state.loopInfo[BLACK].a ? [...state.loopInfo[BLACK].a] : null,
        b: state.loopInfo[BLACK].b ? [...state.loopInfo[BLACK].b] : null,
        ok: Boolean(state.loopInfo[BLACK].ok)
      },
      [WHITE]: {
        a: state.loopInfo[WHITE].a ? [...state.loopInfo[WHITE].a] : null,
        b: state.loopInfo[WHITE].b ? [...state.loopInfo[WHITE].b] : null,
        ok: Boolean(state.loopInfo[WHITE].ok)
      }
    };
    game.loopRepeatCount = state.loopRepeatCount;
    return game;
  }
}

// ========== å‰ç«¯çŠ¶æ€ ==========
let socket = null;
let role = 'spectator';
let localColor = null;
let roomId = null;
let game = null;
let rematchRequested = false;
const ctx = document.getElementById('cv').getContext('2d');

// ========== ç»˜åˆ¶ç©ºæ£‹ç›˜ ==========
function drawEmptyBoard() {
  const pad = 60, span = (600 - 2*pad)/5;
  ctx.clearRect(0, 0, 600, 600);
  for (let i = 0; i < 6; i++) {
    ctx.beginPath();
    ctx.moveTo(pad, pad + i * span);
    ctx.lineTo(pad + 5 * span, pad + i * span);
    ctx.moveTo(pad + i * span, pad);
    ctx.lineTo(pad + i * span, pad + 5 * span);
    ctx.stroke();
  }
}

// ========== è¿æ¥é€»è¾‘ ==========
function connectToRoom(id, asSpectator = false) {
  if (socket) socket.close();
  roomId = id;
  const WORKER_URL = 'wss://dafang-worker.leidejun666.workers.dev';
  
  socket.onopen = () => {
    document.getElementById('connStatus').textContent = 'å·²è¿æ¥';
    document.getElementById('roomText').textContent = id;
    socket.send(JSON.stringify({ type: 'join', asSpectator }));
  };
  
  socket.onmessage = (e) => handleServerMsg(JSON.parse(e.data));
  socket.onclose = () => {
    document.getElementById('connStatus').textContent = 'æ–­å¼€';
    document.getElementById('roomText').textContent = '-';
  };
}

document.getElementById('btnQuickMatch').onclick = () => {
  connectToRoom('match_' + Math.random().toString(36).slice(2, 8), false);
};

document.getElementById('btnCreateRoom').onclick = () => {
  const id = String(Math.floor(Math.random() * 9000) + 1000); // 1000-9999
  connectToRoom(id, false);
  alert(`æˆ¿é—´å·²åˆ›å»º\næˆ¿é—´å·: ${id}\nè¯·åˆ†äº«ç»™å¯¹æ‰‹`);
};

document.getElementById('btnJoinRoom').onclick = () => {
  const id = document.getElementById('roomIdInput').value.trim();
  if (/^\d{4}$/.test(id)) {
    connectToRoom(id, false);
  } else {
    alert('è¯·è¾“å…¥4ä½æ•°å­—æˆ¿é—´å·');
  }
};

document.getElementById('btnSpectate').onclick = () => {
  const id = document.getElementById('roomIdInput').value.trim();
  if (/^\d{4}$/.test(id)) {
    connectToRoom(id, true);
  } else {
    alert('è¯·è¾“å…¥4ä½æ•°å­—æˆ¿é—´å·');
  }
};

// ========== å†æ¥ä¸€å±€ ==========
document.getElementById('btnRematch').onclick = () => {
  if (!game || !game.over || !socket) return;
  if (rematchRequested) return;
  rematchRequested = true;
  socket.send(JSON.stringify({ type: 'rematch_request' }));
  log('ä½ è¯·æ±‚å†æ¥ä¸€å±€...');
};

function showRematchDialog() {
  if (!confirm('å¯¹æ–¹è¯·æ±‚å†æ¥ä¸€å±€ï¼Œæ˜¯å¦åŒæ„ï¼Ÿ')) {
    socket.send(JSON.stringify({ type: 'rematch_reject' }));
    log('ä½ æ‹’ç»äº†å†æ¥ä¸€å±€');
  } else {
    socket.send(JSON.stringify({ type: 'rematch_accept' }));
    log('åŒæ–¹åŒæ„å†æ¥ä¸€å±€');
  }
}

// ========== æ¶ˆæ¯å¤„ç† ==========
function handleServerMsg(msg) {
  if (msg.type === 'assign_role') {
    role = msg.role;
    localColor = msg.color;
    document.getElementById('roleText').textContent = 
      role === 'spectator' ? 'è§‚æˆ˜è€…' : 
      (localColor === BLACK ? 'é»‘æ–¹ç©å®¶' : 'ç™½æ–¹ç©å®¶');
    game = new DafangGameCore(localColor);
    render();
  }
  else if (msg.type === 'sync_state') {
    game = DafangGameCore.fromState(msg.state);
    render();
    if (msg.move) {
      game._log(`${colorName(msg.move.by)} è½å­ (${msg.move.x},${msg.move.y})`);
    }
  }
  else if (msg.type === 'game_over') {
    const winner = msg.winner === null ? 'å’Œæ£‹' : 
                   msg.winner === 1 ? 'é»‘æ–¹èƒœ' : 'ç™½æ–¹èƒœ';
    game._log(`ğŸ ${winner} â€”â€” ${msg.reason}`);
    render();
    rematchRequested = false;
  }
  else if (msg.type === 'rematch_request') {
    showRematchDialog();
  }
  else if (msg.type === 'rematch_start') {
    game = new DafangGameCore(localColor);
    render();
    log('æ–°å±€å¼€å§‹ï¼');
  }
}

// ========== ç”¨æˆ·æ“ä½œ ==========
function canvasClick(e) {
  if (role !== 'player' || !game || game.over || game.turn !== localColor) return;
  const rect = e.target.getBoundingClientRect();
  const x = Math.floor((e.clientY - rect.top) / (rect.height / 6));
  const y = Math.floor((e.clientX - rect.left) / (rect.width / 6));
  socket.send(JSON.stringify({ type: 'move', x, y }));
}
document.getElementById('cv').addEventListener('click', canvasClick);

document.getElementById('btnResign').onclick = () => {
  if (role !== 'player' || !game || game.over) return;
  game.resign(localColor);
  socket.send(JSON.stringify({ type: 'resign' }));
  render();
};

// ========== æ¸²æŸ“ & æ—¥å¿— ==========
function render() {
  const pad = 60, span = (600 - 2*pad)/5;
  ctx.clearRect(0, 0, 600, 600);
  for (let i = 0; i < 6; i++) {
    ctx.beginPath();
    ctx.moveTo(pad, pad + i * span);
    ctx.lineTo(pad + 5 * span, pad + i * span);
    ctx.moveTo(pad + i * span, pad);
    ctx.lineTo(pad + i * span, pad + 5 * span);
    ctx.stroke();
  }
  for (let x = 0; x < 6; x++) {
    for (let y = 0; y < 6; y++) {
      const v = game.board[x][y];
      if (v !== 0) {
        ctx.beginPath();
        ctx.arc(pad + y * span, pad + x * span, 20, 0, Math.PI * 2);
        ctx.fillStyle = v === 1 ? 'black' : 'white';
        ctx.fill();
        ctx.stroke();
      }
    }
  }
  document.getElementById('stageText').textContent = game.stageText();
  document.getElementById('actionHint').textContent = game.actionHint();
  document.getElementById('turnText').textContent = game.over ? '-' : colorName(game.turn);
  document.getElementById('humanColorText').textContent = 
    role === 'spectator' ? 'è§‚æˆ˜' : `${colorName(localColor)}ï¼ˆ${localColor === BLACK ? "å…ˆæ‰‹" : "åæ‰‹"}ï¼‰`;
  const forb = Array.from(game.recentSelfbreakEmpty[game.turn] || []);
  document.getElementById('forbiddenText').textContent = forb.length ? forb.join("  ") : "ï¼ˆæ— ï¼‰";
  
  const el = document.getElementById('log');
  el.textContent = game.log.slice(-200).join('\n');
  el.scrollTop = el.scrollHeight;
}

function log(msg) {
  const el = document.getElementById('log');
  el.textContent += msg + '\n';
  el.scrollTop = el.scrollHeight;
}

// ========== åˆå§‹åŒ– ==========
drawEmptyBoard();
</script>
</body>
</html>